# 基础数据结构的精髓

数组（`Array`）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

**特点：**

1. **线性表：**线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

   而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

2. **连续的内存空间 和 相同类型的数据：**正是因为这两个限制，它才有了一个堪称 “杀手锏” 的特性：“随机访问”。

   但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

## 数组 “插入” 和 “删除” 操作优化

我们都知道，链表适合插入、删除，时间复杂度 `O(1)`；数组支持随机访问适合查找，**根据下标查找**的时间复杂度为 `O(1)`；

连续内存空间的特点导致了**有序数组**插入删除非常低效，但是如果**数组数据无规律**，我们可以在**插入操作**的时候将插入下标原数据搬移到数组最后，把新元素放到插入下标。

比如有数据 `a,b,c,d,e` ，将 `x` 插入到下标为 `2` 的位置，结果为 `a,b,x,d,e,c` ，利用这种处理技巧，在特定场景下，在第 `k` 个位置插入一个元素的时间复杂度就会降为 `O(1)`。

那**删除操作**如何优化呢？

如果是**无序数组**，我们依旧可以用和插入操作类似的方法，记录数组长度，将数据最后一个数据覆盖在需要删除的数据上，然后将最后一个数据置空。

如果是**有序数组**，我们可以将多次删除操作集中在一起执行，比如有数据 `a,b,c,d,e` ，我们要依次删除 `a,b,c` 三个元素，为了避免 `d,e` 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。**每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除**。**当数组没有更多空间存储数据，或者要随机访问的时候**，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

如果你了解 JVM，你会发现，这不就是 JVM **标记清除**垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。

## 数组的访问越界问题

在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。这样就会出现一个问题

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。这里说一个有意思的结果

这段代码的运行结果并非是打印三行 `“hello word”`，而是会无限打印 `“hello world”` ，这是为什么呢？

这里代码因为书写错误，导致 `for` 循环的结束条件错写为了 `i<=3` 而非 `i<3`，所以当 `i=3` 时，数组 `a[3]` 访问越界。由于栈是由高到低位增长的，所以，`i` 和数组的数据从高位地址到低位地址依次是：`i, a[2], a[1], a[0]`，`a[3]` 通过寻址公式，计算得到地址正好是i的存储地址，所以 `a[3]=0`，就相当于 `i=0`，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误，所以就会导致代码无限循环。

## 数组的何时使用？

针对数组类型，很多语言都提供了容器类，比如 `Java` 中的 `ArrayList`、`C++ STL` 中的 `vector`。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？

这里拿 `Java` 举例，`ArrayList ` 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。

不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。

`ArrayList` 这么好是不是数组有无用武之地呢？

当然不是

1. `Java ArrayList` 无法存储基本类型，比如 `int、long`，需要封装为 `Integer、Long` 类，而 `Autoboxing、Unboxing` 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 `ArrayList` 提供的大部分方法，也可以直接使用数组。
3. 当要表示多维数组时，用数组往往会更加直观。比如 `Object[][] array`；而用容器的话则需要这样定义：`ArrayList<ArrayList<Object>> array`。

## 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

从数组存储的内存模型上来看，“下标” 最确切的定义应该是 “偏移（`offset`）”。前面也讲到，如果用 `a` 来表示数组的首地址，`a[0]` 就是偏移为 `0` 的位置，也就是首地址，`a[k]` 就表示偏移 `k` 个 `type_size` 的位置，所以计算 `a[k]` 的内存地址只需要用这个公式：

```
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：

```
a[k]_address = base_address + (k-1)*type_size
```

对比两个公式，我们不难发现，从 `1 `开始编号，每次随机访问数组元素都多了一次减法运算，对于 `CPU` 来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 `0` 开始编号，而不是从 `1 ` 开始。