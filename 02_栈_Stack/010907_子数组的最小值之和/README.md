给定一个整数数组 `A`，找到 `min(B)` 的总和，其中 `B` 的范围为 `A` 的每个（连续）子数组。

由于答案可能很大，因此**返回答案模 `10^9 + 7`**。

**示例：**

```
输入：[3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

**提示：**

1. `1 <= A <= 30000`
2. `1 <= A[i] <= 30000`

# 题解

![clipboard.png](https://pic.leetcode-cn.com/2f59d73899312f0c53eafdc5fc71daa31e221036b8eaca7e897a30c57b44b648-clipboard.png)



比如输入 `[1,3,2]`
`dot = 0, ans = 0`

首先，`1` 入栈，`dot += 1 * 1` ，这个加上的 `1` 对应区间为 `[1]` ，` ans += dot, ans = 1` 

然后，`3` 入栈，`dot += 3 * 1` ，即 `dot = 4 = 1 + 3` ，这里的 `1` 对应的区间为 `[1, 3]` ,  `3` 对应的区间为 `[3]` ，`ans += dot` ，`ans = 1 + （1 + 3）` ，对应的区间为 `[1], [1,3], [3]` 

最后，`2` 入栈前将 `3` 弹出栈，弹出的时候 `dot -= 3 * 1, dot = 1` ，这个剩下的 `1` 对应区间是 `[1,3]` ，被减去的 `3` 代表区间 `[3]` ，因为 `[3,2]` 的最小值是 `2` ，在后面 `2` 入栈的时候才会累加上来，所以现在就需要将其剔除。` 2` 入栈时，`count = 2` ，即两个区间 `[3,2],[2]` 的最小值都是 `2` 。`dot += 2 * 2，dot = 1 + 2 + 2` ，对应的区间为 `[1,3,2], [3,2], [2]` ，`ans += dot` , `ans = 1 + (1 + 3) + (((1 + 3) - 3) + 2 + 2) = 1 + (1 + 3) + (1 + 2 + 2)`。对应区间为 `[1], [1,3], [3],[1,3,2],[3,2],[2]` 

**代码**

```java
    public int sumSubarrayMins(int[] A) {
        int MOD = 1_000_000_007;

        Deque<RepInteger> stack = new LinkedList<>();
        int ans = 0, dot = 0;
        for (int j = 0; j < A.length; ++j) {
            int count = 1;
            // 前一个数 > 当前的数，证明这两个数组成的区间 当前数比较小， 当前数肯定是 这两个数的区间以及自身区间 这两个区间内的最小值
            while (!stack.isEmpty() && stack.peek().val >= A[j]) {
                RepInteger node = stack.pop();

                count += node.count;
                // dot 的作用是 临时保存与当前这个数有关的 所有区间最小值的和，
                // 因为这里是个 while 会和之前所有的值进行比较
                // 比如 1,3,2 最后到 2 的时候 ，dot 当前的值为 [1,3][3] 两个区间最小值的和
                // 添加后会出现新的区间 [1,3,2][3,2][2] （这里可以发现，其实就是在上一次所有的区间上添加了 2，最后添加了一个单独的[2] ）
                //             dot = [1,3]  [3] = 4 (我们只需要将前两个最小值与 2 相比，如果 2 大，最小值不变，如果 2 小，dot - 之前的值 + 2)
                // 循环外 [2] count = 1
                // 第一次循环 [3,2] 3 > 2 所以，在这个区间内 dot 需要减去原来的最小值 [3] ，然后添加 2 (count +1 表示当前值需要添加的个数)
                // 第二次循环 [1,3,2] 1 < 2，剩余 dot 不变。
                dot -= node.val * node.count;
            }
            stack.push(new RepInteger(A[j], count));
            // 添加变更后的区间最小值， count 为几就是变了几个区间
            dot += A[j] * count;
            ans += dot;
            ans %= MOD;
        }
        return ans;
    }
    
    
    
class RepInteger {
    int val, count;

    RepInteger(int v, int c) {
        val = v;
        count = c;
    }
}    
```

**复杂度分析**

- 时间复杂度：O(N)，其中 N*N* 是 `A` 的长度。
- 空间复杂度：O(N)。