序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

```
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
```

例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。

**示例 1:**

```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```

**示例 2:**

```
输入: "1,#"
输出: false
```

**示例 3:**

```
输入: "9,#,#,1"
输出: false
```

## 方法一：迭代

定义一个概念，叫做槽位，二叉树中任意一个节点或者空孩子节点都要占据一个槽位。

二叉树的建立也伴随着槽位数量的变化。

开始时只有一个槽位，如果根节点是空节点，就只消耗掉一个槽位，如果根节点不是空节点，除了消耗一个槽位，还要为孩子节点增加两个新的槽位。

之后的节点也是同理。

- 开始时只有一个可用槽位。
- 空节点和非空节点都消耗一个槽位。
- 空节点不增加槽位，非空节点增加两个槽位。

```java
    public boolean isValidSerialization(String preorder) {
        // 剩余槽位数量
        int slots = 1;

        for(String node : preorder.split(",")) {
            // 当前节点需要一个槽位
            --slots;

            // 如果槽位不够 返回 false
            if (slots < 0) return false;

            // 当前节点不为 # ，证明有两个子节点，槽位 + 2
            if (!node.equals("#")) slots += 2;
        }

        // 所有槽位都应用证明序列化正确
        return slots == 0;
    }
```

**复杂度分析**

- 时间复杂度：O(N)，其中 N 为字符串的长度。
- 空间复杂度：O(N)。

## 方法二：一遍过

方法一 使用了 split 额外维护了一个数组，同样的思路，可以循环字符串进行处理，这样就不用开辟额外空间了。

在遍历过程中，每遇到逗号字符就更新可用槽位的数量（因为可能是多位数，所以需要判断 逗号 字符）。需要注意的是，最后一个节点需要单独处理，因为最后一个节点后面没有逗号字符。

```java
    public boolean isValidSerialization(String preorder) {
        // 剩余槽位数量
        int slots = 1;
        int n = preorder.length();
        for(int i = 0; i < n; ++i) {
            if (preorder.charAt(i) == ',') {
                // 当前节点需要一个槽位
                --slots;

                // 如果槽位不够 返回 false
                if (slots < 0) return false;

                // 当前节点不为 # ，证明有两个子节点，槽位 + 2
                if (preorder.charAt(i - 1) != '#') slots += 2;
            }
        }
        // 最后一个节点
        slots = (preorder.charAt(n - 1) == '#') ? slots - 1 : slots + 1;
        // 所有槽位都应用证明序列化正确
        return slots == 0;
    }
```

**复杂度分析**

- 时间复杂度：O(N)，其中 N 为字符串的长度。
- 空间复杂度：O(1)，只占用常数空间。