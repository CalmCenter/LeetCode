请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。

# 题解一 暴力解法

- 倒序循环每一天，并且在 `next` 中记录温度以及当天的下标（下标表示需要等待的天数）
- 从当天温度开始，在 `next` 中寻找更高的温度的下标，并且保存在 `warmerIndex` 中
- 然后用 `warmerIndex` 减去当前天数下标，就是当前天数需要等待多少天后有更高的温度

```java
    public int[] dailyTemperatures(int[] T) {
        int length = T.length;
        int[] ans = new int[length];
        // 每个温度的 等待天数
        int[] next = new int[101];
        Arrays.fill(next, Integer.MAX_VALUE);
        // 倒序循环天数
        for (int i = length - 1; i >= 0; --i) {
            // 用于记录更高温度的等待天数
            int warmerIndex = Integer.MAX_VALUE;
            // 从 当前温度 + 1 开始遍历，循环所有大于当前温度的温度，查询是否有记录等待天数
            for (int t = T[i] + 1; t <= 100; ++t) {
                // next[t] < warmerIndex 说明当前温度 t 在有记录等待天数
                // 找出等待天数最小的一个天数，由于是倒序循环的天数，所以 next[t] 肯定大于 i
                if (next[t] < warmerIndex) {
                    warmerIndex = next[t];
                }
            }
            // warmerIndex 不为默认值，证明 warmerIndex 天后有更高的温度
            if (warmerIndex < Integer.MAX_VALUE) {
                // 更高温度的等待天数 - 当前温度的等待天数 = 当前温度需要等待几天后有更高温度
                ans[i] = warmerIndex - i;
            }
            // 记录当前温度的等待天数
            next[T[i]] = i;
        }
        return ans;
    }
```

**复杂度分析**

时间复杂度：O(nm)，其中 n 是温度列表的长度，m 是数组 next 的长度，在本题中温度不超过 100，所以 m 的值为 100。反向遍历温度列表一遍，对于温度列表中的每个值，都要遍历数组 next 一遍。

空间复杂度：O(m)，其中 m 是数组 next 的长度。除了返回值以外，需要维护长度为 m 的数组 next 记录每个温度第一次出现的下标位置。

# 题解二 单调栈

```
[73,74,75,71,69,72,76,73]
stack: 
  ans:
```

`stack` 保存温度的下标，也就是第几天，`ans` 保存需要等待几天有更高的温度

- 当 `i=0` 时，单调栈为空，因此将 `0` 进栈。

  ```
  stack:[0(73)] 
    ans:[0,0,0,0,0,0,0,0]
  ```

- 当 `i=1` 时，`74(第 i 天温度) > 73(栈顶那天温度)`，那么出栈第 `0` 天，计算第 `0` 天等待天数，`ans[0] = 1 - 0`，然后将第 `1` 天入栈

  ```
  stack:[1(74)] 
    ans:[1,0,0,0,0,0,0,0]
  ```

- 当 `i=2` 时，`75 > 74`，那么出栈第 `1` 天，计算第 `1` 天等待天数，`ans[0] = 2 - 1`，然后将第 `2` 天入栈

  ```
  stack:[2(75)] 
    ans:[1,1,0,0,0,0,0,0]
  ```

- 当 `i=3` 时，由于 `71` 小于 `75`，因此将 `3` 进栈。

  ```
  stack:[2(75)，3(71)] 
    ans:[1,1,0,0,0,0,0,0]
  ```

- 当 `i=4` 时，由于 `69` 小于 `71`，因此将 `4` 进栈。

  ```
  stack:[2(75),3(71),4(69)] 
    ans:[1,1,0,0,0,0,0,0]
  ```

- 当 `i=5` 时，由于 `72` 大于 `69` 和 `71`，因此依次移除栈顶元素 `4` 和 `3`，并计算第 `4、3` 天等待天数 `ans[4] = 5 - 4` 和 `ans[3] = 5 - 3` ，最后将 `5` 进栈

  ```
  stack:[2(75),5(72)] 
    ans:[1,1,0,2,1,0,0,0]
  ```

- 当 `i=6` 时，由于 `76` 大于 `72` 和 `75`，因此依次移除栈顶元素 `5` 和 `2`，并计算第 `5、2` 天等待天数 `ans[5] = 6 - 5` 和 `ans[2] = 6 - 2` ，最后将 `6` 进栈

  ```
  stack:[6(76)] 
    ans:[1,1,4,2,1,1,0,0]
  ```

- 当 `i=7` 时，由于 `73 < 76` ，将 `7` 进栈，遍历结束

  ```
  stack:[6(76),7(73)] 
    ans:[1,1,4,2,1,1,0,0]
  ```

**代码**

```java
    public int[] dailyTemperatures(int[] T) {
        int length = T.length;
        int[] ans = new int[length];
        Deque<Integer> stack = new LinkedList<>();
        // 循环每一天
        for (int i = 0; i < length; i++) {
            // 记录第 i 天温度
            int temperature = T[i];
            // 如果第 i 天温度 比 栈顶那天温度高，则对于 栈顶那天,第 i 天就是更高温度的那天,需要 计算等待天数
            while (!stack.isEmpty() && temperature > T[stack.peek()]) {
                // 出栈栈顶元素，返回是下标，表示第几天
                int prevIndex = stack.pop();
                //  i  - 栈顶那天 = 栈顶那天 需要等待几天后有更高温度
                ans[prevIndex] = i - prevIndex;
            }
            // 栈内保存第几天
            stack.push(i);
        }
        return ans;
    }
```

**复杂度分析**

时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。

空间复杂度：O(n)，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。

