给你一份工作时间表 `hours`，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 `8` 小时的时候，那么这一天就是「**劳累的一天**」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 **大于**「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

**示例 1：**

```
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
```

**提示：**

- `1 <= hours.length <= 10000`
- `0 <= hours[i] <= 16`

# 题解 暴力

工作时间大于 8 则属于劳累的一天，否则属于悠闲一天。对于数组的每个元素，只有两种状态，劳累 or 悠闲。

要知道劳累的天数多还是优先天数多，就可以用 1 表示当天劳累，-1 表示当天优先。

对于天数区间 `[i,j]`，累加值为正，说明劳累天数更多。

- 先将工作天数转化为用 1，-1 表示状态的数组
- 然后对每一个天数区间`[i,j]`，计算这个区间的累加和，如果大于 0 则更新「表现良好时间段」的最大长度。

```java
    public int longestWPI(int[] hours) {
        int n = hours.length;
        // 将工作时长的劳累程度转化为 1 和 -1
        for(int i = 0; i < n; i++){
            hours[i] = hours[i] > 8 ? 1 : -1;
        }
        int res = 0;
        // 循环每个天数区间 [0,1]、[0,2] .. [n,n] ，计算劳累程度总和，记录最大值
        // i 表示区间在第几天开始    j 表示区间在第几天结束
        for(int i = 0; i < n; i++){
            int count = 0;
            for(int j = i; j < n; j++){
                count += hours[j];
                // count > 0 表示「劳累的天数」是严格 大于「不劳累的天数」。
                if(count > 0)
                    // 记录劳累程度最大值
                    res = Math.max(res, j - i + 1);
            }
            if(n - i <= res)
                return res;
        }
        return res;
    }
```

**复杂度分析**

时间复杂度：O(n^2)

空间复杂度：O(1)

# 题解二 哈希表记录前缀和的索引

- 用 1 表示当天劳累，-1 表示当前悠闲。



```
9 9 6 0 6 6 6 6 9 9 9 9
    ↑
    i
res : 3
sum : 1
```

前三个循环没什么好讲的，正常记录良好时段，`sum > 0` 满足 「劳累的天数」是严格 大于「不劳累的天数」

```
0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
      ↑
      i
res : 3
sum : 0
sumToIndex : [0,3]

0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
        ↑
        i
res : 3
sum : -1
sumToIndex : [0,3],[-1,4]

0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
          ↑
          i
res : 3
sum : -2
sumToIndex : [0,3],[-1,4],[-2,5]

0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
            ↑
            i
res : 3
sum : -3
sumToIndex : [0,3],[-1,4],[-2,5],[-3,6]

0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
              ↑
              i
res : 3
sum : -4
sumToIndex : [0,3],[-1,4],[-2,5],[-3,6],[-4,7]
```

这里将 不劳累天数的下标 保存在了 `sumToIndex` 里。`s` 表示 `sumToIndex.get(sum - 1)`

```
0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
              ↑ ↑
              s i
res : 3
sum : -3
sumToIndex : [0,3],[-1,4],[-2,5],[-3,6],[-4,7]
i - sumToIndex.get(sum - 1) : 8 - 7 = 1  // 表示下标为 8 时满足良好时段


0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
            ↑     ↑
            s     i 
res : 3
sum : -2
sumToIndex : [0,3],[-1,4],[-2,5],[-3,6],[-4,7]
i - sumToIndex.get(sum - 1) : 9 - 6 = 3 // 表示下标为 7 8 9 时满足良好时段


0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
          ↑         ↑
          s         i 
res : 5
sum : -1
sumToIndex : [0,3],[-1,4],[-2,5],[-3,6],[-4,7]
i - sumToIndex.get(sum - 1) : 10 - 5 = 3 // 表示下标为 6 7 8 9 10 时满足良好时段


0 1 2 3 4 5 6 7 8 9 10 11
9 9 6 0 6 6 6 6 9 9 9  9
        ↑              ↑
        s              i 
res : 7
sum : 0
sumToIndex : [0,3],[-1,4],[-2,5],[-3,6],[-4,7]
i - sumToIndex.get(sum - 1) : 11 - 4 = 7 // 表示下标为 5 6 7 8 9 10 11 时满足良好时段
```

这里的 `s` 就好比当前 `i` 下标的一个对称点，并且严格满足  `「劳累的天数」- 1 >=「不劳累的天数」`

这组数据，如果在多一个 9 或者 少一个 6 ， `sum` 就会大于 0 ，然后全部数据满足满足良好时段

```java
    public int longestWPI(int[] hours) {
        int sum = 0;
        int res = 0;
        Map<Integer, Integer> sumToIndex = new HashMap<>();
        for(int i = 0; i < hours.length; i++){
            int temp = hours[i] > 8 ? 1 : -1;
            sum += temp;
            // sum > 0 表示当前整个数据满足 「劳累的天数」- 1 >=「不劳累的天数」
            if(sum > 0)
                // 所以用当前下标直接 + 1,表示所有数据
                res = i + 1;
            else {
                // 记录 「不劳累的天」的下标
                if(!sumToIndex.containsKey(sum))
                    sumToIndex.put(sum, i);
                // sum - 1  表示 以下标为 sum - 1 开始 到当前下标 i，满足 「劳累的天数」是严格 大于「不劳累的天数」。
                if(sumToIndex.containsKey(sum - 1))
                    // 良好时段记录
                    res = Math.max(res, i - sumToIndex.get(sum - 1));
            }
        }
        return res;
    }
```

**复杂度分析**

时间复杂度：O(n)

空间复杂度：O(n)，取决于哈希表中的元素的个数

