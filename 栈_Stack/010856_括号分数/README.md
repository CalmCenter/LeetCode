给定一个平衡括号字符串 `S`，按下述规则计算该字符串的分数：

- `()` 得 1 分。
- `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串。
- `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串。

**示例 1：**

```
输入： "()"
输出： 1
```

**示例 2：**

```
输入： "(())"
输出： 2
```

**示例 3：**

```
输入： "()()"
输出： 2
```

**示例 4：**

```
输入： "(()(()))"
输出： 6
```

**提示：**

1. `S` 是平衡括号字符串，且只含有 `(` 和 `)` 。
2. `2 <= S.length <= 50`

# 题解一 分治

对于一个字符串 `S`，我们将左括号 `(` 记为 `1`，右括号记为 `-1` 

我们标记左括号下标 `i` ，然后寻找该最括号对应的右括号，每遇到一个左括号 `+1` ，遇到一个右括号 `-1` 。如果每个下标结果为 `0` 证明当前下标 `k` 就是 `i` 所对应的右括号。

如果 `k - i == 1`  证明当前括号是一个不可拆分的。

否则需要将括号进行拆分。

- 对于一个不可拆分的平衡括号字符串，如果它为 `()`，那么就得 `1` 分
- 否则它的最外层一定有一对左右括号，可以将这对括号去除后继续进行拆分，再将得到的分数乘 `2`。

```java
    public int scoreOfParentheses(String S) {
        return F(S, 0, S.length());
    }

    public int F(String S, int i, int j) {
        // Score of balanced string S[i:j]
        int ans = 0, bal = 0;

        // Split string into primitives
        for (int k = i; k < j; ++k) {
            bal += S.charAt(k) == '(' ? 1 : -1;
            if (bal == 0) {
                // bal == 0 表示 找到 当前位置 i 所对应的 结束括号 k 的位置
                // k-i == 1 表示这个括号中没有子括号 表现为 ()
                if (k - i == 1) ans++;
                else {
                    // k - i != 1 表示存在子括号，从下一位开始计算子括号分数，分数计算方式为 2 * 子括号分数
                    ans += 2 * F(S, i + 1, k);
                }
                // 更新 i 为结束括号的下一位
                i = k + 1;
            }
        }
        return ans;
    }
```

复杂度分析

时间复杂度：O(N^2)，其中 N 是字符串 S 的长度，在最坏的情况下，字符串 S 为 (((((((....)))))))，它需要拆分 O(N) 次，每次遍历字符串的时间复杂度也为 O(N)。

空间复杂度：O(N)。

# 题解二 栈

- `[0, 0]` `(`
- `[0, 0, 0]` `((`
- `[0, 1]` `(()`
- `[0, 1, 0]` `(()(`
- `[0, 1, 0, 0]` `(()((`
- `[0, 1, 1]` `(()(()`
- `[0, 3]` `(()(())`
- `[6]` `(()(()))`

```java
    public int scoreOfParentheses(String S) {
        Deque<Integer> stack = new LinkedList<>();
        // 处理最后一个 () 的情况
        stack.push(0);

        for (char c: S.toCharArray()) {
            if (c == '(')
                stack.push(0);
            else {
                // 如果出现 ) 第一个 pop 如果是 0 则表明是一对平衡括号，如果不是 0 则是嵌套括号，将结果 * 2
                int v = stack.pop();
                // 表示同级括号的得分
                int w = stack.pop();
                stack.push(w + Math.max(2 * v, 1));
            }
        }

        return stack.pop();
    }
```

**复杂度分析**

- 时间复杂度：O(N)，其中 N 是字符串 `S` 的长度。
- 空间复杂度：O(N)，为栈的大小。

# 题解三 统计核心的数目

事实上，我们可以发现，只有 `()` 会对字符串 `S` 贡献实质的分数，其它的括号只会将分数乘二或者将分数累加。

因此，我们可以找到每一个 `()` 对应的深度 `x`，那么答案就是 `2^x` 的累加和。

```java
    public int scoreOfParentheses(String S) {
        // bal 表示当前深度
        int ans = 0, bal = 0;
        for (int i = 0; i < S.length(); ++i) {
            if (S.charAt(i) == '(') {
                bal++;
            } else {
                bal--;
                // 如果前一字符时 ( 怎么这里出现了 () 然后，计算当前深度 () 可以获得多少积分
                if (S.charAt(i-1) == '(')
                    ans += 1 << bal;
            }
        }

        return ans;
    }
```

**复杂度分析**

- 时间复杂度：O(N)，其中 N 是字符串 `S` 的长度。
- 空间复杂度：O(1)。